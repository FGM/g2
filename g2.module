<?php
/**
 * This defines a node-based glossary module,
 * as opposed to the term-based glossary module in drupal 4.6/4.7
 * Copyright (C) 2005-2006 Frederic G. MARAND
 * Licensed under the CeCILL, version 2
 * $Id$
 */

/**
 * Constants missing from older node.module versions (still missing from node.module 1.582, see http://drupal.org/node/43355)
 */
if (!defined('NODE_PUBLISHED'))
  {
  define('NODE_NOT_PUBLISHED', 0);
  define('NODE_PUBLISHED', 1)  ;
  define('NODE_NOT_IN_MODERATION', 0);  // moderate
  define('NODE_IN_MODERATION', 1);
  define('NODE_NOT_PROMOTED', 0);       // promote
  define('NODE_PROMOTED', 1);
  define('NODE_NOT_STICKY', 0);         // sticky
  define('NODE_STICKY', 1);
  }

/**
 * G2 various constants
 */
define('G2NODETYPE',          'g2_entry');
define('G2PERMVIEW',          'view g2 entries');
define('G2PERMADMIN',         'administer g2 entries');
define('G2VERSION',           '$Id$');

/**
 * G2 menu information
 */
define('G2PATHAUTOCOMPLETE',  'g2/autocomplete');
define('G2PATHENTRIES',       'g2/entries');
define('G2PATHINITIAL',       'g2/initial');
define('G2PATHNODEADD',       'node/add/' . G2NODETYPE);
define('G2PATHWOTDFEED',      'g2/wotd/feed');
define('G2PATHREFERERWIPE',   'g2/wipe');
define('G2TITLEAUTOCOMPLETE', t('entry autocomplete'));
define('G2TITLEENTRIES',      t('G2 entries by name'));
define('G2TITLEINITIAL',      t('entries starting by initial %initial'));
define('G2TITLEMAIN',         t('G2 glossary main page'));
define('G2TITLEWOTDFEED',     t('G2 word of the day RSS feed'));
define('G2TITLEREFERERWIPE',  t('Wipe all G2 referer information'));

/**
 * G2 settings and block configuration, persisted in {variable}
 */
define('G2VARALPHABAR',       'g2_alphabar');       // Alphabar block: list of the one-symbol initials being displayed
define('G2VARALPHABARROWLEN', 'g2_alphabar_rowlen');// Alphabar block: row length of the themed alphabar
define('G2VARALPHABARTITLE',  'g2_alphabar_title'); // Alphabar block: title
define('G2VARGOTOSINGLE',     'g2_goto_single');    // Automatically go to the match on an "entries" page if only one exists
define('G2VARHIDDENTITLE',    'g2_hidden_title');   // Does hook_view include a hidden version of title for hook_update_index
define('G2VARHOMONYMS',       'g2_homonyms');       // disambiguation page for homonyms
define('G2VARHOMONYMSREDIRECT', 'g2_homonyms_redirect');// The HTTP 30x code to be used for automatic redirects
define('G2VARHOMONYMSVID',    'g2_homonyms_vid');   // disambiguation vocabulary id for homonyms
define('G2VARLATESTITEMCOUNT','g2_latest_item_count');// Latest(x) block: value of x
define('G2VARLATESTTITLE',    'g2_latest_title');   // Latest(x) block: title
define('G2VARMAIN',           'g2_main');           // nid of the node used as main page for G2
define('G2VARPAGETITLE',      'g2_page_title');     // Override for default site title on G2 pages
define('G2VARPATHMAIN',       'g2_pathmain');       // path for the G2 main page
define('G2VARNOFREETAGGING',  'g2_nofreetagging');  // Hide information from freetagging vocabularies to non-G2 admin
define('G2VARRANDOMENTRY',    'g2_random_entry');   // Random block: latest pseudo-random entry displayed
define('G2VARRANDOMSTORE',    'g2_random_store');   // Random block: store the latest random entry
define('G2VARRANDOMTERMS',    'g2_random_terms');   // Random block: show terms bound to entry
define('G2VARRANDOMTITLE',    'g2_random_title');   // Random block: title
define('G2VARREMOTEG2',       'g2_remote_g2');      // Base URL of remote G2 instance
define('G2VARRPCTHROTTLE',    'g2_rpc_throttle');   // Coefficient limit for XML-RPC operations over block settings
define('G2VARWOTDAUTOCHANGE', 'g2_wotd_autochange');// WOTD block: automatically change the WOTD once a day
define('G2VARWOTDBODYSIZE',   'g2_wotd_bodysize');  // WOTD block: number of body characters to be displayed in the block
define('G2VARWOTDDATE',       'g2_wotd_date');      // WOTD block: date for which this WOTD entry is current
define('G2VARWOTDENTRY',      'g2_wotd_entry');     // WOTD block: current entry
define('G2VARWOTDFEEDLINK',   'g2_wotd_feed_link'); // WOTD block feed: include a link to the WOTD RSS feed in the block
define('G2VARWOTDFEEDTITLE',  'g2_wotd_feed_title');// WOTD block feed: the title for the WOTD RSS feed
define('G2VARWOTDFEEDDESCR',  'g2_wotd_feed_descr');// WOTD block feed: the description for the WOTD RSS feed
define('G2VARWOTDFEEDAUTHOR', 'g2_wotd_feed_author');//WOTD block feed: include the author in the feed entries
define('G2VARWOTDTITLE',      'g2_wotd_title');     // WOTD block: title
define('G2VARWOTDTERMS',      'g2_wotd_terms');     // WOTD block: show terms bound to entry
define('G2VARTOPITEMCOUNT',   'g2_top_item_count'); // Top(x) block: value of x
define('G2VARTOPTITLE',       'g2_top_title');      // Top(x) block: title
define('G2VARXMLRPC',         'g2_xmlrpc');         // Is the XML-RPC server enabled ?

/**
 * G2 default values for some of the persistent variables above
 */
define('G2DEFAULTALPHABAR',      '0123456789abcdefghijklmnopqrstuvwxyz');
define('G2DEFAULTHOMONYMSREDIRECT', '302');// The HTTP 30x code to be used for automatic redirects
define('G2DEFAULTPATHMAIN',      'g2');
define('G2DEFAULTRPCTHROTTLE',   10);
define('G2DEFAULTPAGETITLE',     t('G2 Glossary on %title'));
define('G2DEFAULTREMOTEG2',      'http://www.riff.org/g2/entries');
define('G2DEFAULTREMOTENO',      '<local>');
define('G2DEFAULTWOTDTITLE',     t('Word of the day in the G2 glossary'));
define('G2DEFAULTWOTDFEEDDESCR', t("A daily definition from the G2 Glossary at %site"));  // see _g2_wotd_feed()
define('G2DEFAULTWOTDFEEDAUTHOR',"%author"); // This default will use the actual node author

/**
 * ========== Unimplemented hooks below: ==========
 **/
/*
function g2_execute(&$node)
function g2_prepare(&$node)
function g2_comment($comment, $op)
function g2_db_rewrite_sql($query, $primary_table, $primary_field, $args)
function g2_elements()
function g2_exit($destination = NULL)
function g2_file_download($file)
function g2_footer($main = 0)
function g2_form_alter($form_id, &$form_values)
function g2_init()
function g2_link($type, $node = NULL, $teaser = FALSE)
function g2_user($op, &$edit, &$user, $category = NULL)
function g2_onload()
function g2_node_grants($user, $op)
function g2_ping($name = '', $url = '') {
function g2_search($op = 'search', $keys = null) {}
function g2_search_item($item) {}
function g2_search_preprocess($text) -- for Asian languages only ?
function g2_update_index()
function g2_taxonomy($op, $type, $object = NULL)
*/

/**
 * Return alphabar data
 */
function _g2_alphabar()
  {
  $rawalphabar = variable_get(G2VARALPHABAR, G2DEFAULTALPHABAR);
  $ret = array();
  for ($i = 0 ; $i < strlen($rawalphabar) ; $i++)
    {
    $c = drupal_substr($rawalphabar,$i,1);
    $path = _g2_terminal_encode($c);
    $ret[] = l($c, G2PATHINITIAL . "/$path", NULL, NULL, NULL, TRUE, true);
    }
  return $ret;
  }

/**
 * AJAX autocomplete for entry
 *
 * @param string $string The beginning of the entry
 * @see g2_menu()
 * @see g2_block()
 */
function _g2_autocomplete($string = NULL)
  {
  $matches = array();
  if (isset($string))
    {
    $q = db_query_range("SELECT title FROM {node} WHERE LOWER(title) LIKE LOWER('%s%%') and type = '" . G2NODETYPE . "' and (status = 1)", $string, 0, 10);
    while ($result = db_fetch_object($q)) {
      $matches[$result->title] = check_plain($result->title);
    // watchdog('g2', "string = $string, matches: " . print_r($matches, TRUE), WATCHDOG_NOTICE);
    }
  }
  print drupal_to_js($matches);
  exit();
  }

/**
 * Provides the block-specific contents common to each G2 block: ability to rename the block and change its title
 *
 * @param array $form The current form for which this is built
 * @param string $infotitle Block information: the title
 * @param string $infovar Block information: the config variable name
 * @param string $infodefault Block information: the default name
 * @param string $titletitle Block title: the title
 * @param string $titlevar Block title: the config variable name
 * @param string $titledefault Block title: the default title
 * @return void
 */
function _g2_block_settings_show(&$form, $infotitle, $infovar, $infodefault, $titletitle, $titlevar, $titledefault)
  {
  $form['info']   = array
    (
    '#type'          => 'textfield',
    '#title'         => $infotitle,
    '#default_value' => variable_get('g2_' . $infovar . '_info', $infodefault),
    '#weight'        => -2,
    );
  $form['title']   = array
    (
    '#type'          => 'textfield',
    '#title'         => $titletitle,
    '#default_value' => variable_get('g2_' . $titlevar . '_title', $titledefault),
    '#weight'        => -1,
    );
  }

function _g2_block_settings_save($edit, $blockname)
  {
  variable_set('g2_' . $blockname . '_info',  $edit['info' ]);
  variable_set('g2_' . $blockname . '_title', $edit['title']);
  }

/**
 * Remove unwanted terms from a taxonomy array
 *
 * @param array $taxonomy array of fully loaded terms (tid, vid, weight..)
 */
function _g2_comb_taxonomy($taxonomy)
  {
  $vocabs = array();
  if (variable_get(G2VARNOFREETAGGING, true)) // These are hidden by default
    {
    // We still hide the terms within freetagging vocabularies to allow partial display
    foreach ($taxonomy as $key => $value)
      {
      // Is the current term in a freetagging vocabulary ?
      if (!array_key_exists($value->vid, $vocabs))
        {
        $vocab = taxonomy_get_vocabulary($value->vid);
        $vocabs[$value->vid] = $vocab->tags;
        }

      if ($vocabs[$value->vid] == true)
        unset ($taxonomy[$key]);
      }
    }
  return $taxonomy;
  }

/**
 * Return a span containing links to taxonomy terms, or nothing
 * if node information contains no terms. The "node" passed must
 * contain full term information, not just tids.
 * @param object $node imitation of a node
 */
function _g2_entry_terms($node)
  {
  if (sizeof($node->taxonomy) > 0)
    {
    $ret = ' <span class="taxonomy">' ;
    foreach ($node->taxonomy as $term)
      {
      $ret .= l($term->name, "taxonomy/term/$term->tid", array('rel' => 'tag', 'title' => $term->title)) . ' | ';
      }
    $ret = substr($ret, 0, strlen($ret) - 3);
    $ret .= '</span>' ;
    }
  return $ret;
  }

/**
 * Return a list of words starting by an initial segment
 * (typically one letter, but this can be any starting substring)
 * The logic is different from the one in _g2_entries because
 * we don't care for the case of "/" as an initial segment
 *
 * @param string $initial
 * @return string HTML
 */
function _g2_initial($initial)
  {
  $initial = check_plain($initial);
  $arTotal   = _g2_stats();
  $arInitial = _g2_stats(0, $initial);
  $ret = t("<p>Displaying %count entries starting by '%initial' from a total number of %total entries.</p>",
    array(
      // Since _g2_stats() no longer returns empty arrays, we no longer need to check values
      '%count'   => $arInitial[NODE_PUBLISHED],
      '%initial' => $initial,
      '%total'   => $arTotal  [NODE_PUBLISHED],
      )
    );
  if (user_access(G2PERMADMIN))
    {
    $ret .= t('<p>Admin info: there are also %count unpublished matching entries from a total number of %total unpublished entries.</p>',
      array(
        '%count' => $arInitial[NODE_NOT_PUBLISHED],
        '%total' => $arTotal[NODE_NOT_PUBLISHED],
        )
      );
    }
  unset($arInitial);
  unset($arTotal);

  $sq = "select n.nid, v.title, v.teaser from {node} n inner join {node_revisions} v on n.vid = v.vid "
    . " where (n.type='%s') and (v.title like '%s%%') and (n.status = 1) "
    . "order by v.title ";
  $q = db_query($sq, G2NODETYPE, $initial);
  $ar = array();
  while ($result = db_fetch_object($q))
    {
    $teaser = strip_tags($result->teaser);
    $ar[] = l($result->title, "node/$result->nid", FALSE , FALSE, FALSE, FALSE, TRUE)
      . t(': %teaser', array('%teaser' => $teaser))
      . l(' (+)', "node/$result->nid", array('class' => 'read-more'));
    }
  $ret .= theme('item_list', $ar);
  return $ret;
  }

function _g2_ip_ban()
  {
  return xmlrpc_error();
  }

/**
 * Returns a list of the latest n nodes
 * as counted by time of update
 * @return array
 */
function _g2_latest($max = null)
  {
  $defmax = variable_get (G2VARLATESTITEMCOUNT, 10);
  $rpcthrottle =  variable_get (G2VARRPCTHROTTLE, G2DEFAULTRPCTHROTTLE);
  if (empty($max) or ($max > $rpcthrottle*$defmax)) // Limit extraction
    {
    $max = $defmax;
    }
  $sq = "select n.title, n.nid, n.status from {node} n where (n.type = '" . G2NODETYPE . "') order by n.changed desc";
  $q = db_query_range($sq, 0, $max);
  $ret = array();
  while ($row = db_fetch_object($q))
    {
    $ret[] = $row;
    }
  return $ret;
  }

/**
 * Ancillary function for g2_block to return a pseudo-random entry
 * selected to be different from the current WOTD and, in the
 * default setting, from the latest pseudo-random result returned.
 * Only works for glossaries with 3 entries or more.
 * @return object title / nid / teaser
 */
function _g2_random()
  {
  $wotd   = variable_get(G2VARWOTDENTRY, '');

  // Count the allowed nodes
  if (variable_get(G2VARRANDOMSTORE, True))
    {
    $random = variable_get(G2VARRANDOMENTRY, '');
    $sq = 'select count(*) cnt '
        . 'from {node} n '
        . "where n.type = '" . G2NODETYPE . "' and (n.status = 1) and not (n.title = '%s' or n.nid = %d)" ;
    $q = db_query($sq, $random, $wotd);
    }
  else
    {
    $random = '';
    $sq = "select count(*) cnt from {node} n where n.type = '" . G2NODETYPE . "' and (n.status = 1) and not (n.nid = %d)" ;
    $q = db_query($sq, $wotd);
    }
  $ret = db_fetch_object($q);
  $n = $ret->cnt;
  $rand = rand(0, $n - 1);

  // Select from the exact same list of nodes, assuming none was inserted/deleted in the meantime
  $sq = 'select n.title, n.nid, v.teaser '
      . 'from {node} n inner join {node_revisions} v on n.vid = v.vid '
      . "where n.type = '" . G2NODETYPE . "' and (n.status = 1) and not (n.title = '%s' or n.nid = %d)" ;
  $q = db_query_range($sq, $random, $wotd, $rand, 1);
  $ret = db_fetch_object($q);

  if (variable_get(G2VARRANDOMTERMS, FALSE))
    {
    $taxonomy = taxonomy_node_get_terms($ret->nid);

    // Currently an OSInet.fr private extension. Ignored on other sites.
    if (function_exists('_osinode_comb_taxonomy'))
      {
      $taxonomy = _osinode_comb_taxonomy ($taxonomy);
      }
    $ret->taxonomy = $taxonomy;
    unset ($taxonomy);
    }
  // echo "<pre>ret = " . print_r($ret, TRUE) . ", terms: " . print_r($x, TRUE) . "</pre>";
  if (variable_get(G2VARRANDOMSTORE, True))
    {
    variable_set(G2VARRANDOMENTRY, $ret->title);
    }
  return $ret;
  }

/**
 * Counts the number of entries matching two criteria:
 * @param int $tid Term Id (ignored if 0)
 * @param string $initial Start of entry (ignored if null)
 * @return string HTML
 */
function _g2_referer_links()
  {
  $nid = arg(1);
  $sq = "SELECT gr.referer, gr.incoming "
      . "FROM {g2_referer} gr "
      . "WHERE gr.nid = %d "
      . "ORDER BY gr.incoming DESC";
  $q = db_query($sq, $nid);
  $ar = array();
  while ($o = db_fetch_object($q))
    {
    $ar[] = l(
      t("%link : %incoming incoming clicks", array('%link' => $o->referer, '%incoming' => $o->incoming)),
      $o->referer,
      NULL,
      NULL,
      NULL,
      TRUE);
    }
  $ret = theme('item_list', $ar, '');
  $ret .= t('WARNING: just because a click came from a node doesn\'t mean the node has a link.
        The click may have come from a block on the page. These stats are just a hint for editors.');
  $ret = theme('box', t('Local referers for this node'), $ret);

  $form = array();
  $form['#action'] = url(G2PATHREFERERWIPE . '/' . $nid, null, null, true);
  $form['submit'] = array(
    '#type'       => 'submit',
    '#value'      => t('Wipe referer info for this entry'),
    );

  $ret .= drupal_get_form('g2_referer_wipe', $form);
  return $ret;
  }

/**
 * Erase the referer counts on g2 entries
 *
 * @param int $nid Node from which to erase referers, or null to erase all g2 referers
 * @return void
 */
function _g2_referer_wipe($nid = NULL)
  {
  if (isset($nid))
    {
    $sq .= 'DELETE from {g2_referer} WHERE nid = %d';
    db_query($sq, check_plain($nid));
    drupal_goto(drupal_get_path_alias("node/$nid"));
    }
  else
    {
    $sq .= 'DELETE from {g2_referer}';
    db_query($sq);
    drupal_goto(url('admin/settings/g2', null, null, true));
    }
  }

/**
 * Extract statistics from the G2 glossary
 * - g2 entries having chosen taxonomy term
 * - g2 entries starting by chosen initial segment
 *
 * @param int $tid Taxonomy term id
 * @param string $initial Initial segment
 * @return array
 */
function _g2_stats($tid = 0, $initial = NULL)
  {
  $test1 = false;
  $test2 = false;

  $sq = "SELECT status, count(distinct n.nid) cnt FROM {node} n ";
  $sq_test = ' n.type = \'' . G2NODETYPE . "' ";
  if (isset($tid) && $tid > 0)
    {
    $sq .= "INNER JOIN {term_node} tn ON n.nid = tn.nid WHERE tn.tid = %d AND $sq_test ";
    $test1 = true;
    }
  else
    {
    $sq .= "WHERE $sq_test ";
    }
  if (isset($initial) && $initial <> '')
    {
    $sq .= "AND n.title like '%s%%' ";
    $test2 = true;
    }
  $sq .= 'GROUP BY status';
  if ($test1 && $test2)
    $q = db_query($sq, $tid, $initial);
  elseif ($test1)
    $q = db_query($sq, $tid);
  elseif ($test2)
    $q = db_query($sq, $initial);
  else
    $q = db_query($sq);

  // Avoid empty returns
  $ret = array(NODE_NOT_PUBLISHED => 0, NODE_PUBLISHED => 0)  ;

  while ($o = db_fetch_object($q))
    {
    $ret[$o->status] = $o->cnt;
    }
  return $ret;
  }

/**
 * Returns a list of the top n nodes
 * as counted by statistics.module
 * @param $max
 * @return array
 */
function _g2_top($max = null)
  {
  $defmax = variable_get (G2VARTOPITEMCOUNT, 10);
  $rpcthrottle =  variable_get (G2VARRPCTHROTTLE, G2DEFAULTRPCTHROTTLE);
  if (empty($max) or ($max > $rpcthrottle*$defmax)) // Limit extraction
    {
    $max = $defmax;
    }
  $sq = "select n.title, n.nid, n.status from {node} n inner join {node_counter} c on n.nid = c.nid where (n.type = '" . G2NODETYPE . "') and (c.totalcount is not null) order by c.totalcount desc, n.changed desc";
  $q = db_query_range($sq, 0, $max);
  $ret = array();
  while ($row = db_fetch_object($q))
    {
    $ret[] = $row;
    }
  return $ret;
  }

/**
 * Returns a structure for the WOTD.
 * Limitation: always returns just the FIRST entry for a given word
 * @param int $bodysize
 * @return object title / nid / teaser
 */
function _g2_wotd($bodysize = 0)
  {
  // No need for a static: this function is normally never called twice

  $sqhead = 'select n.title, n.nid, v.teaser' ;
  $entrynid = variable_get(G2VARWOTDENTRY, 0);

  if ($bodysize > 0)
    $sqhead .= ', v.body';
  $sq = $sqhead
    . " from {node} n inner join {node_revisions} v on n.vid = v.vid where n.type='"
    . G2NODETYPE
    . "' and (n.status = 1) and (n.nid=%d)";
  $q = db_query_range($sq, $entrynid, 0, 1);
  $ret = db_fetch_object($q);
  if (variable_get(G2VARWOTDTERMS, FALSE))
    {
    $ret->taxonomy = _g2_comb_taxonomy(taxonomy_node_get_terms($ret->nid));
    }
  return $ret;
  }

/**
 * Generate an RSS feed containing the latest WOTD
 * @return string XML in UTF-8 encoding
 */
function _g2_wotd_feed()
 {
 global $base_url;

 $channelinfo = array
   (
   // Link element:  Drupal 4.7 defaults to $base url
   // Language: Drupal 4.7 defaults to $locale
   'title'          => variable_get(G2VARWOTDFEEDTITLE, variable_get(G2VARWOTDTITLE, G2DEFAULTWOTDTITLE)),  // Drupal defaults to site name - site slogan
   'description'    => strtr(variable_get(G2VARWOTDFEEDDESCR, G2DEFAULTWOTDFEEDDESCR), array('%site' => $base_url)), // Drupal defaults to $site_mission
   'managingEditor' => variable_get('site_mail', 'nobody@example.com'),
   );
 $sq = "select n.nid from {node} n where n.nid = '%d'"; // Silly looking, but node_feed needs to be passed a query
 $q = db_query($sq, variable_get(G2VARWOTDENTRY, 0));
 $ret = node_feed($q, $channelinfo);
 return $ret;
 }

/**
 * Define access restrictions.
 *
 * This hook allows node modules to limit access to the node types they
 * define.
 *
 * @param $op string
 * @param $node int
 *   The node on which the operation is to be performed, or, if it does
 *   not yet exist, the type of node to be created.
 * @return boolean
 *   TRUE if the operation may be performed; FALSE if the operation may not be
 *   returned; NULL to not override the settings in the node_access table.
 *
 * The administrative account (user ID #1) always passes any access check,
 * so this hook is not called in that case. If this hook is not defined for
 * a node type, all access checks will fail, so only the administrator will
 * be able to see content of that type. However, users with the "administer
 * nodes" permission may always view and edit content through the
 * administrative interface.
 */
function g2_access($op, $node)
  {
  global $user;

  switch ($op)
    {
    case 'create':
    case 'delete':
    case 'update':
      $ret = user_access(G2PERMADMIN);
      break;
    case 'view':
      $ret = user_access(G2PERMVIEW);
      break;
    }
  return $ret;
  }

/**
 * Declare a block or set of blocks.
 *
 * Any module can export a block (or blocks) to be displayed by defining
 * the _block hook. This hook is called by theme.inc to display a block,
 * and also by block.module to procure the list of available blocks.
 *
 * @param $op string
 *   What kind of information to retrieve about the block or blocks.
 *   Possible values:
 *   - 'list': A list of all blocks defined by the module.
 *   - 'configure': A configuration form.
 *   - 'save': Save the configuration options.
 *   - 'view': Information about a particular block.
 * @param $delta int
 *   Which block to return (not applicable if $op is 'list').
 * @param $edit array
 *   If $op is 'save', the submitted form data from the configuration form.
 * @return mixed
 *   If $op is 'list', return an array of arrays, each of which must define an
 *   'info' element describing the block. If $op is 'configure', optionally
 *   return a string containing the configuration form. If $op is 'save',
 *   return nothing, If $op is 'view', return an array which must define a
 *   'subject' element and a 'content' element defining the block indexed by
 *   $delta.
 *
 * The functions mymodule_display_block_1 and 2, as used in the example,
 * should of course be defined somewhere in your module and return the
 * content you want to display to your users. If the "content" element
 * is empty, no block will be displayed even if "subject" is present.
 *
 * After completing your blocks, do not forget to enable them in the
 * block admin menu.
 *
 * For a detailed usage example, see block_example.module.
 */
function g2_block($op = 'list', $delta = 0, $edit = array()) {
  if ($op == 'list')
    {
    $blocks[0]['info'] = variable_get('g2_alphabar_info', t('G2 Alphabar'));
    $blocks[1]['info'] = variable_get('g2_random_info',   t('G2 Random'));
    $blocks[2]['info'] = variable_get('g2_top_info',      t('G2 Top'));
    $blocks[3]['info'] = variable_get('g2_wotd_info',     t('G2 Word of the day'));
    $blocks[4]['info'] = variable_get('g2_latest_info',   t('G2 Latest'));
    return $blocks;
    }
  elseif ($op == 'configure')
    {
    switch ($delta)
      {
      case 0: // Alphabar
        $form['alphabar'] = array
          (
          '#type'          => 'textfield',
          '#title'         => t('List of initials to be included in alphabar'),
          '#default_value' => variable_get(G2VARALPHABAR, G2DEFAULTALPHABAR),
          '#description'   => t('The alphabar lists the initials for which links to initial pages will be included.')
          );
        $form['rowlen']   = array
          (
          '#type'          => 'textfield',
          '#title'         => t('Maximum length of lines in the alphabar'),
          '#default_value' => variable_get(G2VARALPHABARROWLEN, 13),
          '#size'          => 3,
          '#description'   => t('Each line except the last one will have exactly that number of links.')
          );
        _g2_block_settings_show($form,
          t('Name of the block in the block list'), 'alphabar', t('G2 Alphabar'),
          t('Title of the block when displayed'),   'alphabar', t('G2 Glossary pages'));
        break;
      case 1: // Random
        $form['random_store'] = array
          (
          '#type'          => 'checkbox',
          '#title'         => t('Store latest random entry'),
          '#default_value' => variable_get(G2VARRANDOMSTORE, TRUE),
          '#description'   => t('When this setting is true (default value),
               the latest random value is kept in the DB to avoid showing the same pseudo-random
               value on consecutive page displays.
               For small sites, it is usually best to keep it saved.
               For larger sites, unchecking this setting will remove one database write with locking.'),
          );
        $form['random_terms'] = array(
          '#type'          => 'checkbox',
          '#title'         => t('Return taxonomy terms for the current entry'),
          '#default_value' => variable_get(G2VARRANDOMTERMS, FALSE),
          '#description'   => t('The taxonomy terms will be returned by XML-RPC and made available to the theme.
               Default G2 themeing will display them.'),
          );
        _g2_block_settings_show($form,
          t('Name of the block in the block list'), 'random', t('G2 Random'),
          t('Title of the block when displayed'),   'random', t('Random G2 glossary entry'));
        break ;
      case 2: // Top
        $topcount = variable_get(G2VARTOPITEMCOUNT, 10);
        $form['itemcount'] = array
          (
          '#type'          => 'select',
          '#title'         => t('Number of items'),
          '#default_value' => $topcount,
          '#options'       => array('1' => '1', '2' => '2', '5' => '5', '10' => '10')
          );
        _g2_block_settings_show($form,
          t('Name of the block in the block list'), 'top', sprintf (t('G2 Top %d'), $topcount),
          t('Title of the block when displayed'),   'top', t('%d most popular G2 glossary entries'));
        break;
      case 3: // WOTD
        /**
         * @see _g2_autocomplete()
         */
        $node = node_load(variable_get(G2VARWOTDENTRY, 0));
        $form['wotd_entry'] = array
          (
          '#type'          => 'textfield',
          '#title'         => t('Entry for the day'),
          '#maxlength'     => 60,
          '#autocomplete_path' => G2PATHAUTOCOMPLETE,
          '#required'      => TRUE,
          '#default_value' => $node->title,
          );
        $form['wotd_bodysize'] = array
          (
          '#type'          => 'textfield',
          '#title'         => t('Number of text characters to be displayed from entry definition body, if one exists'),
          '#size'          => 4,
          '#maxlength'     => 4,
          '#required'      => TRUE,
          '#default_value' => variable_get(G2VARWOTDBODYSIZE, '')
          );
        $form['wotd_autochange'] = array
          (
          '#type'          => 'checkbox',
          '#title'         => t('Auto-change daily'),
          '#required'      => TRUE,
          '#default_value' => variable_get(G2VARWOTDAUTOCHANGE, TRUE),
          '#description'   => t('This setting will only work if cron or poormanscron is used.')
          );

        $form['wotd_terms'] = array(
          '#type'          => 'checkbox',
          '#title'         => t('Return taxonomy terms for the current entry'),
          '#default_value' => variable_get(G2VARWOTDTERMS, FALSE),
          '#description'   => t('The taxonomy terms will be returned by XML-RPC and made available to the theme.
               Default G2 themeing will display them.'),
          );
        $form['wotd_feed'] = array(
          '#type'          => 'fieldset',
          '#title'         => 'RSS Feed',
          );
        $form['wotd_feed']['wotd_feed_link'] = array(
          '#type'          => 'checkbox',
          '#title'         => t('Display feed link'),
          '#default_value' => variable_get(G2VARWOTDFEEDLINK, TRUE),
          '#description'   => t('Should the theme display the link to the RSS feed for this block ?'),
          );
        $form['wotd_feed']['wotd_feed_title'] = array(
          '#type'          => 'textfield',
          '#title'         => t('The feed title'),
          '#size'          => 60,
          '#maxlength'     => 60,
          '#required'      => TRUE,
          '#default_value' => variable_get(G2VARWOTDFEEDTITLE, variable_get(G2VARWOTDTITLE, G2DEFAULTWOTDTITLE)),
          '#description'   => t('The title for the feed itself.
               This will typically be used by aggregators to remind users of the feed and link to it.
               If nulled, G2 will reset it to the title of the block.'),
          );
        $form['wotd_feed']['wotd_feed_author'] = array(
          '#type'          => 'textfield',
          '#title'         => t('The feed item author'),
          '#size'          => 60,
          '#maxlength'     => 60,
          '#required'      => TRUE,
          '#default_value' => variable_get(G2VARWOTDFEEDAUTHOR, G2DEFAULTWOTDFEEDAUTHOR),
          '#description'   => t('The author name to be included in the feed entries.
               In this string %author will be replaced by the actual author information.
               Defaults to %author.'),
          );
        $form['wotd_feed']['wotd_feed_descr'] = array(
          '#type'          => 'textfield',
          '#title'         => t('The feed description'),
          '#size'          => 60,
          '#maxlength'     => 60,
          '#required'      => TRUE,
          '#default_value' => variable_get(G2VARWOTDFEEDDESCR, G2DEFAULTWOTDFEEDDESCR),
          '#description'   => t('The description for the feed itself.
               This will typically be used by aggregators when describing the feed prior to subscription.
               It may contain %site, which will dynamically be replaced by the site base URL.
               If nulled, G2 will reset it to a default description.'),
          );

        _g2_block_settings_show($form,
          t('Name of the block in the block list'), 'wotd', t('G2 Word of the day'),
          t('Title of the block when displayed'),   'wotd', t('Word of the day in the G2 glossary'));
        break;
      case 4: // Latest
        $latestcount = variable_get(G2VARLATESTITEMCOUNT, 10);
        $form['itemcount'] = array
          (
          '#type'          => 'select',
          '#title'         => t('Number of items'),
          '#default_value' => $latestcount,
          '#options'       => array('1' => '1', '2' => '2', '5' => '5', '10' => '10')
          );
        _g2_block_settings_show($form,
          t('Name of the block in the block list'), 'latest', sprintf (t('G2 Latest %d'), $latestcount),
          t('Title of the block when displayed'),   'latest', t('%d most recently updated G2 glossary entries'));
        break;
      default:
        break;
      }
    return $form;
    }
  elseif ($op == 'save')
    {
    //echo "<pre>block/SAVE" . print_r($edit, TRUE) . "</pre>";
    switch ($delta)
      {
      case 0: // Alphabar
        variable_set(G2VARALPHABAR, $edit['alphabar']);
        variable_set(G2VARALPHABARROWLEN, $edit['rowlen']);
        _g2_block_settings_save($edit, 'alphabar');
        break;
      case 1: // Random
        variable_set(G2VARRANDOMTERMS,    $edit['random_terms']);
        _g2_block_settings_save($edit, 'random');
        break;
      case 2: // Top
        variable_set(G2VARTOPITEMCOUNT, $edit['itemcount']);
        _g2_block_settings_save($edit, 'top');
        break;
      case 3: // WOTD
        $node = node_load(array('title' => $edit['wotd_entry']));
        variable_set(G2VARWOTDENTRY,      $node->nid);
        variable_set(G2VARWOTDBODYSIZE,   $edit['wotd_bodysize']);
        variable_set(G2VARWOTDAUTOCHANGE, $edit['wotd_autochange']);
        variable_set(G2VARWOTDDATE,       mktime());
        variable_set(G2VARWOTDTERMS,      $edit['wotd_terms']);
        variable_set(G2VARWOTDFEEDLINK,   $edit['wotd_feed_link']);
        variable_set(G2VARWOTDFEEDTITLE,  $edit['wotd_feed_title']);
        variable_set(G2VARWOTDFEEDDESCR,  $edit['wotd_feed_descr']);
        variable_set(G2VARWOTDFEEDAUTHOR, $edit['wotd_feed_author']);
        _g2_block_settings_save($edit, 'wotd');
        break;
      case 4: // Top
        variable_set(G2VARLATESTITEMCOUNT, $edit['itemcount']);
        _g2_block_settings_save($edit, 'latest');
      default:
        break;
      }
    }
  elseif ($op == 'view')
    {
    // watchdog('g2', "hook_block/view/$delta");
    switch($delta)
      {
      case 0:
        $block['subject'] = variable_get(G2VARALPHABARTITLE, t('G2 Glossary pages'));
        $block['content'] = theme('g2_block_alphabar');
        break;
      case 1:
        $block['subject'] = variable_get(G2VARRANDOMTITLE,   t('Random G2 glossary entry'));
        $block['content'] = theme('g2_block_random');
        break;
      case 2:
        $block['subject'] = sprintf (
          variable_get(G2VARTOPTITLE,     t('%d most popular G2 glossary entries')),
          variable_get(G2VARTOPITEMCOUNT, 10));
        $block['content'] = theme('g2_block_top');
        break;
      case 3:
        $block['subject'] = variable_get(G2VARWOTDTITLE, G2DEFAULTWOTDTITLE);
        $block['content'] = theme('g2_block_wotd');
        break;
      case 4:
        $block['subject'] = sprintf (
          variable_get(G2VARLATESTTITLE,     t('%d most recently updated G2 glossary entries')),
          variable_get(G2VARLATESTITEMCOUNT, 10));
        $block['content'] = theme('g2_block_latest');
        break;
      }
    return $block;
    }
}

/**
 * In G2's case, change the WOTD once a day if this feature
 * is enabled, which is the default case.
 *
 * @return void
 *
 * This hook will only be called if cron.php is run (e.g. by crontab).
 */
function g2_cron()
  {
  if (variable_get(G2VARWOTDAUTOCHANGE, TRUE))
    {
    $date0 = date('z', variable_get(G2VARWOTDDATE, mktime()));
    $date1 = date('z');
    if ($date1 <> $date0)
      {
      $random = _g2_random();
      // watchdog("g2_cron", "d0 = $date0, d1 = $date1, random : " . print_r($random,TRUE) . "</pre>");
      variable_set (G2VARWOTDENTRY, $random->nid);
      variable_set (G2VARWOTDDATE,  mktime());
      }
    }
  }

/**
 * Respond to node deletion.
 *
 * This is a hook used by node modules. It is called to allow the module
 * to take action when a node is being deleted from the database by, for
 * example, deleting information from related tables.
 *
 * @param &$node int
 *   The node being deleted.
 * @return void
 *
 * To take action when nodes of any type are deleted (not just nodes of
 * the type defined by this module), use hook_nodeapi() instead.
 */
function g2_delete(&$node) {
  db_query('DELETE FROM {g2_node} WHERE nid = %d', $node->nid);
}

/**
 * Define content filters.
 *
 * Content in Drupal is passed through all enabled filters before it is
 * output. This lets a module modify content to the site administrator's
 * liking.
 *
 * This hook contains all that is needed for having a module provide filtering
 * functionality.
 *
 * Depending on $op, different tasks are performed.
 *
 * A module can contain as many filters as it wants. The 'list' operation tells
 * the filter system which filters are available. Every filter has a numerical
 * 'delta' which is used to refer to it in every operation.
 *
 * Filtering is a two-step process. First, the content is 'prepared' by calling
 * the 'prepare' operation for every filter. The purpose of 'prepare' is to
 * escape HTML-like structures. For example, imagine a filter which allows the
 * user to paste entire chunks of programming code without requiring manual
 * escaping of special HTML characters like @< or @&. If the programming code
 * were left untouched, then other filters could think it was HTML and change
 * it. For most filters however, the prepare-step is not necessary, and they can
 * just return the input without changes.
 *
 * Filters should not use the 'prepare' step for anything other than escaping,
 * because that would short-circuits the control the user has over the order
 * in which filters are applied.
 *
 * The second step is the actual processing step. The result from the
 * prepare-step gets passed to all the filters again, this time with the
 * 'process' operation. It's here that filters should perform actual changing of
 * the content: transforming URLs into hyperlinks, converting smileys into
 * images, etc.
 *
 * An important aspect of the filtering system are 'input formats'. Every input
 * format is an entire filter setup: which filters to enable, in what order
 * and with what settings. Filters that provide settings should usually store
 * these settings per format.
 *
 * If the filter's behaviour depends on an extensive list and/or external data
 * (e.g. a list of smileys, a list of glossary terms) then filters are allowed
 * to provide a separate, global configuration page rather than provide settings
 * per format. In that case, there should be a link from the format-specific
 * settings to the separate settings page.
 *
 * For performance reasons content is only filtered once; the result is stored
 * in the cache table and retrieved the next time the piece of content is
 * displayed. If a filter's output is dynamic it can override the cache
 * mechanism, but obviously this feature should be used with caution: having one
 * 'no cache' filter in a particular input format disables caching for the
 * entire format, not just for one filter.
 *
 * Beware of the filter cache when developing your module: it is advised to set
 * your filter to 'no cache' while developing, but be sure to remove it again
 * if it's not needed. You can clear the cache by running the SQL query 'DELETE
 * FROM cache';
 *
 * @param string $op
 *  Which filtering operation to perform. Possible values:
 *   - list: provide a list of available filters.
 *     Returns an associative array of filter names with numerical keys.
 *     These keys are used for subsequent operations and passed back through
 *     the $delta parameter.
 *   - no cache: Return true if caching should be disabled for this filter.
 *   - description: Return a short description of what this filter does.
 *   - prepare: Return the prepared version of the content in $text.
 *   - process: Return the processed version of the content in $text.
 *   - settings: Return HTML form controls for the filter's settings. These
 *     settings are stored with variable_set() when the form is submitted.
 *     Remember to use the $format identifier in the variable and control names
 *     to store settings per input format (e.g. "mymodule_setting_$format").
 * @param int $delta
 *   Which of the module's filters to use (applies to every operation except
 *   'list'). Modules that only contain one filter can ignore this parameter.
  * @param int $format
 *   Which input format the filter is being used in (applies to 'prepare',
 *   'process' and 'settings').
 * @param string $text
 *   The content to filter (applies to 'prepare' and 'process').
 * @return string
 *   The return value depends on $op. The filter hook is designed so that a
 *   module can return $text for operations it does not use/need.
 *
 * For a detailed usage example, see filter_example.module. For an example of
 * using multiple filters in one module, see filter_filter() and
 * filter_filter_tips().
 */
function g2_filter($op, $delta = 0, $format = -1, $text = '') {
  switch ($op) {
    case 'list':
      return array(0 => t('G2 Glossary filter'));

    case 'description':
      return t('Allows users to link to G2 entries using &lt;dfn&gt; elements.');

    case 'prepare':
      // Note: we use the bytes 0xFE and 0xFF to replace < > during the filtering process.
      // These bytes are not valid in UTF-8 data and thus least likely to cause problems.
      $text = preg_replace('@<dfn>(.+?)</dfn>@s', "\xFEdfn\xFF\\1\xFE/dfn\xFF", $text);
      return $text;

    case "process":
      $text = preg_replace('@\xFEdfn\xFF(.+?)\xFE/dfn\xFF@se', "_g2_filter_process('$1')", $text);
      return $text;

    default:
      return $text;
  }
}

/**
 * Provide tips for using filters.
 *
 * A module's tips should be informative and to the point. Short tips are
 * preferably one-liners.
 *
 * @param $delta
 *   Which of this module's filters to use. Modules which only implement one
 *   filter can ignore this parameter.
 * @param $format
 *   Which format we are providing tips for.
 * @param $long
 *   If set to true, long tips are requested, otherwise short tips are needed.
 * @return stringe
 *   The text of the filter tip.
 *
 *
 */
function g2_filter_tips($delta, $format, $long = false) {
  if ($long) {
    return t('Wrap <dfn> elements around the terms for which you want a link to the available G2 definition(s).');
  }
  else {
    return t('You may link to G2 definitions using &lt;dfn&gt; elements.');
  }
}

/**
 * Translate glossary linking elements (<dfn>) to actual links)
 * This function generates absolute links, for the benefit of the WOTD RSS feed
 * If this feed is not used, it is possible to use the (shorter) relative URLs
 * by swapping comments.
 * @param string $entry An entry
 * @return string HTML
 */
function _g2_filter_process($entry)
  {
  $target = variable_get(G2VARREMOTEG2, G2DEFAULTREMOTEG2);
  if ($target == G2DEFAULTREMOTENO) /* Then we are not using a remote glossary */
    {
    $target = G2PATHENTRIES;
    }
  // $ret = l($entry, G2PATHENTRIES ."/$entry");
  $path = urlencode(_g2_terminal_encode($entry));
  $ret = l($entry, "$target/$path", NULL, NULL, NULL, TRUE, FALSE);
  return $ret;
  }

/**
 * Display a node editing form.
 *
 * This hook, implemented by node modules, is called to retrieve the form
 * that is displayed when one attempts to "create/edit" an item. This form is
 * displayed at the URI http://www.example.com/?q=node/<add|edit>/nodetype.
 *
 * @param $node int
 *   The node being added or edited.
 * @param $param array
 *   The hook can set this variable to an associative array of attributes
 *   to add to the enclosing \<form\> tag.
 * @return array
 *   An array containing the form elements to be displayed in the node
  *   edit form.
 *
 * The submit and preview buttons, taxonomy controls, and administrative
  * accoutrements are displayed automatically by node.module. This hook
  * needs to return the node title, the body text area, and fields
 * specific to the node type.
 *
 * For a detailed usage example, see node_example.module.
 */
function g2_form(&$node, &$param)
  {
  if (!isset($node->title))
    {
    $node->title = check_plain(substr($_REQUEST['q'], strlen(G2PATHNODEADD) + 1)) ;
    }

  $form['content'] = array(
    '#type'        => 'fieldset',
    '#title'       => 'Contents',
    '#collapsible' => TRUE,
    '#collapsed'   => FALSE,
    '#weight'      => -10
    );
  $form['content']['title'] = array(
    '#type'          => 'textfield',
    '#title'         => t('Title'),
    '#required'      => TRUE,
    '#default_value' => $node->title
    );
  $form['content']['teaser'] = array(
    '#type'          => 'textfield',
    '#title'         => t('Entry expansion (for acronyms) or translation'),
    '#required'      => FALSE,
    '#default_value' => $node->teaser
    );
  $form['content']['body'] = array(
    '#type'          => 'textarea',
    '#title'         => t('Entry definition'),
    '#rows'          => 10,
    '#required'      => TRUE,
    '#default_value' => $node->body
    );
  $form['content']['period'] = array(
    '#type'          => 'textfield',
    '#title'         => t('Life period of this entry'),
    '#required'      => FALSE,
    '#description'   => t('This is the period of time during which the entity described by the term was actually alive, not the lifetime of the term itself, since any term is immortal to some extent.'),
    '#default_value' => $node->period
    );
  $form['publishing'] = array(
    '#type'          => 'fieldset',
    '#title'         => 'Editor-only information',
    '#collapsible'   => TRUE,
    '#collapsed'     => TRUE,
    '#description'   => 'Information in this box is not published in view mode, only during node edition.',
    '#weight'        => 0
    );
  $form['publishing']['complement'] = array(
    '#type'          => 'textarea',
    '#title'         => t('Complement'),
    '#rows'          => 10,
    '#required'      => FALSE,
    '#description'   => t('Information not pertaining to origin of document: comments, notes...'),
    '#default_value' => $node->complement
    );
  $form['publishing']['origin'] = array(
    '#type'          => 'textarea',
    '#title'         => t('Origin/I.P.'),
    '#rows'          => 10,
    '#required'      => FALSE,
    '#description'   => t('Informations about the origin/IP licensing of the definition'),
    '#default_value' => $node->origin
    );

  $form['format'] = filter_form($node->format);
  return $form;
  }

/**
 * Provide online user help.
 *
 * By implementing hook_help(), a module can make documentation
 * available to the engine or to other modules. All user help should be
 * returned using this hook; developer help should be provided with
 * Doxygen/api.module comments.
 *
 * @param $section string
 *   Drupal URL path (or: menu item) the help is being requested for, e.g.
 *   admin/node or user/edit. Recognizes special descriptors after a "#"
 *   sign. Some examples:
 *   - user/help#modulename
 *     The help for a distributed authorization module (if applicable).
 * @return string
 *   A localized string containing the help text. Every web link, l(), or
 *   url() must be replaced with %something and put into the final t()
 *   call:
 *   $output .= 'A role defines a group of users that have certain
 *     privileges as defined in %permission.';
 *   $output = t($output, array('%permission' => l(t('user permissions'),
 *     'admin/user/permission')));
 */
function g2_help($section)
  {
  $ret = '';
  switch ($section) {
    case 'admin/modules#name':
      $ret = 'g2';
      break;
    case 'admin/help#g2':
      $ret = t('<p>G2 defines a glossary service for Drupal sites. To compare it with the default Drupal glossary:
           <ul><li>G2 content is node-based, not term-based</li>
             <li>G2 leverages existing code from glossary for input filtering and node marking</li>
             <li>G2 RAM use does not significantly increase with larger entry counts, which makes is more suitable for larger glossaries</li>
             <li>G2 requests much less from the database than the default glossary</li>
             <li>G2 uses three taxonomy vcabularies: context, period, and grammatical nature.</li>
             <li>G2 defines optional blocks</li>
             <li>G2 is remotely usable via XML-RPC</li>
             <li>G2 does not provide term feeds</li>
             <li>G2 access control is simplistic, targeted to non-community sites</ul></p>');
      break;
    case 'admin/modules#description':
      $ret = t('G2 manages a node-based glossary.');
      break;
    case 'node/add#' . G2NODETYPE:
      $ret = t('A G2 entry is a term (usual sense, not drupal sense) for which a definition
            and various additional information is provided, notably at the editorial level');
      break ;
    case 'admin/block/configure/g2/0':
      $ret = t('This block displays a clickable list of initials from the G2 glossary.');
      break;
    case 'admin/block/configure/g2/1':
      $ret = t('This block displays a pseudo-random entry (different each time) from the G2 glossary.');
      break;
    case 'admin/block/configure/g2/2':
      $stats = module_exist('statistics');
      $count = variable_get('statistics_count_content_views', NULL);
      $ar = array();
      $ar[] = $stats
        ? t('Statistics module installed and activated: OK.')
        : t('Statistics module not installed or not activated. Install and activate it and try again.');
      $ret .= '"' . t('Count content views') . '" ' . t('setting is ') ;
      $ret .= ($count > 0) ? 'ON: OK' : 'OFF: Error. Please enabled this counter in admin/settings/statistics';
      $ar[] = $ret;
      $ret = theme('item_list', $ar, t("Dependencies checklist"));
      break;
    case 'admin/block/configure/g2/3':
      $ret = t('This block displays a once-a-day entry from the G2 glossary.');
      break;
    default: // ignore, this hook is called all over the place in 4.7b1
      //$ret = "g2_help($section)";
    }
  return $ret;
  }

/**
 * Respond to node insertion.
 *
 * This is a hook used by node modules. It is called to allow the module
 * to take action when a new node is being inserted in the database by,
 * for example, inserting information into related tables.
 *
 * @param $node  int
 * @return void
 *
 * To take action when nodes of any type are inserted (not just nodes of
 * the type(s) defined by this module), use hook_nodeapi() instead.
 */
function g2_insert($node)
  {
  db_query("INSERT INTO {g2_node} (nid, period, complement, origin)
    VALUES (%d, '%s', '%s', '%s')", $node->nid, $node->period, $node->complement, $node->origin);
  }

/**
 * Load node-type-specific information.
 *
 * This is a hook used by node modules. It is called to allow the module
 * a chance to load extra information that it stores about a node, or
  * possibly replace already loaded information - which can be dangerous.
 *
 * @param $node int
 *   The node being loaded. At call time, node.module has already loaded
 *   the basic information about the node, such as its node ID (nid),
 *   title, and body.
 * @return object
 *   An object containing properties of the node being loaded. This will
 *   be merged with the passed-in $node to result in an object containing
 *   a set of properties resulting from adding the extra properties to
 *   the passed-in ones, and overwriting the passed-in ones with the
 *   extra properties if they have the same name as passed-in properties.
 */
function g2_load($node)
  {
  $ret = db_fetch_object(db_query('SELECT * FROM {g2_node} WHERE nid = %s', $node->nid));
  return $ret;
  }

/**
 * Define menu items and page callbacks.
 *
 * This hook enables modules to register paths which whose requests they wish to handle.
 * Depending on the type of registration requested by each path, a link is placed in the
 * the navigation block and/or an item appears in the menu administration page (q=admin/menu).
 *
 * This hook is also a good place to put code which should run exactly once
 * per page view. Put it in an if (!may_cache) block.
 *
 * @param boolean $may_cache
 *   A boolean indicating whether cacheable menu items should be returned. The
 *   menu cache is per-user, so items can be cached so long as they are not
 *   dependent on the user's current location. See the local task definitions
 *   in node_menu() for an example of uncacheable menu items.
 * @return array
 *   An array of menu items. Each menu item is an associative array that may
 *   contain the following key-value pairs:
 *   - "path": Required. The path to link to when the user selects the item.
 *   - "title": Required. The translated title of the menu item.
 *   - "callback": The function to call to display a web page when the user
 *     visits the path. If omitted, the parent menu item's callback will be used
 *     instead.
 *   - "callback arguments": An array of arguments to pass to the callback function.
 *   - "access": A boolean value that determines whether the user has access
 *     rights to this menu item. Usually determined by a call to user_access().
 *     If omitted and "callback" is also absent, the access rights of the parent
 *     menu item will be used instead.
 *   - "weight": An integer that determines relative position of items in the menu;
 *     higher-weighted items sink. Defaults to 0. When in doubt, leave this alone;
 *     the default alphabetical order is usually best.
 *   - "type": A bitmask of flags describing properties of the menu item.
 *     Many shortcut bitmasks are provided as constants in menu.inc:
 *     - MENU_NORMAL_ITEM: Normal menu items show up in the menu tree and can be
 *       moved/hidden by the administrator.
 *     - MENU_ITEM_GROUPING: Item groupings are used for pages like "node/add"
 *       that simply list subpages to visit.
 *     - MENU_CALLBACK: Callbacks simply register a path so that the correct
 *       function is fired when the URL is accessed.
 *     - MENU_DYNAMIC_ITEM: Dynamic menu items change frequently, and so should
 *       not be stored in the database for administrative customization.
 *     - MENU_SUGGESTED_ITEM: Modules may "suggest" menu items that the
 *       administrator may enable.
 *     - MENU_LOCAL_TASK: Local tasks are rendered as tabs by default.
 *     - MENU_DEFAULT_LOCAL_TASK: Every set of local tasks should provide one
 *       "default" task, that links to the same path as its parent when clicked.
 *     If the "type" key is omitted, MENU_NORMAL_ITEM is assumed.
 *
 * For a detailed usage example, see page_example.module.
 *
 */
function g2_menu($may_cache)
  {
  global $user;
  $items = array();

  $view_access  = (user_access(G2PERMVIEW)  || ($user->uid == arg(1)));
  $admin_access = (user_access(G2PERMADMIN) || ($user->uid == arg(1)));
  if ($may_cache)
    {
    $items[] = array // AJAX autocomplete callback
      (
      'path'     => G2PATHAUTOCOMPLETE,
      'title'    => G2TITLEAUTOCOMPLETE,
      'callback' => '_g2_autocomplete',
      'access'   => $view_access,
      'type'     => MENU_CALLBACK
      );
    $items[] = array //
      (
      'path'     => G2PATHINITIAL,
      'callback' => 'theme',
      'callback arguments' => array('g2_initial'),
      'access'   => $view_access,
      'type'     => MENU_CALLBACK
      );
    $items[] = array
      (
      'path'     => G2PATHENTRIES,
      'title'    => G2TITLEENTRIES,
      'callback' => 'theme',
      'callback arguments' => array('g2_entries'),
      'access'   => $view_access,
      'type'     => MENU_CALLBACK
      );
    $items[] = array // G2 main page
      (
      'path'     => variable_get(G2VARPATHMAIN, G2DEFAULTPATHMAIN),
      'title'    => G2TITLEMAIN,
      'callback' => 'theme',
      'callback arguments' => array('g2_main'),
      'access'   => $view_access,
      'type'     => MENU_NORMAL_ITEM
      );
    $items[] = array // Add a G2 entry
      (
      'path'     => G2PATHNODEADD,
      'title'    => t('G2 entry'),
      'access'   => $admin_access,
      'type'     => MENU_NORMAL_ITEM
      );
    $items[] = array // WOTD feed
      (
      'path'     => G2PATHWOTDFEED,
      'title'    => G2TITLEWOTDFEED,
      'callback' => _g2_wotd_feed,
      'access'   => $view_access,
      'type'     => MENU_CALLBACK,
      );
    $items[] = array // Clear referers for a given entry
      (
      'path'     => G2PATHREFERERWIPE,
      'title'    => t('Wipe referer info for this entry'),
      'callback' => _g2_referer_wipe,
      'access'   => $admin_access,
      'type'     => MENU_CALLBACK,
      );
    }
  else
    {
    if (arg(0) == 'node' && is_numeric(arg(1)))
      {
      $node = node_load(arg(1));
      if ($node->type == G2NODETYPE)
        {
        $items[] = array
          (
          'path'     => 'node/'. arg(1) .'/links',
          'title'    => t('referers'),
          'callback' => '_g2_referer_links',
          'access'   => $admin_access,
          'type'     => MENU_LOCAL_TASK,
          'weight'   => 2
          );
        }
      unset($node);
      }
    }


  return $items;
  }

/**
 * Define the human-readable name of a node type.
 *
 * This is a hook used by node modules. This hook is required of modules
 * that define a node type. It is called to determine the names of the module's
 * nodes.
 *
 * @return array
 *   An array of information on the module's nodes. The array contains a
 *   sub-array for each node with the node name as the key. Each sub-array has
 *   two elements, 'name' and 'base'.
 *
 * The 'name' value is a human-readable name for the node and while the 'base'
 * value tells Drupal how a module's functions map to hooks (i.e. if the base
 * is example_foo then example_foo_insert will be called when inserting the
 * node).
 *
 * To prevent namespace conflicts, each node type defined by a module
 * should be prefixed by the name of the module and an underscore.
 *
 * For a detailed usage example, see node_example.module.
 */
function g2_node_info()
  {
  return array
    (
    G2NODETYPE => array('name' => t('G2 entry'), 'base' => 'g2')
    );
  }


/**
 * Change the publication date for the WOTD feed
 * so that even old terms, when chosen for publication, reflect the
 * publication date, instead of the node creation date as is the default.
 * Do not apply to non-G2 nodes. Do not apply to non-WOTD feeds.
 *
 * @param object $node
 * @param string $op
 * @param boolean $teaser
 * @param boolean $page
 */
function g2_nodeapi(&$node, $op, $teaser = NULL, $page = NULL)
  {
  if (($op == 'rss item') && ($node->type == G2NODETYPE) && ($_GET['q'] == G2PATHWOTDFEED))
    {
    $node->created = variable_get(G2VARWOTDDATE, time());
    $node->name = strtr(variable_get(G2VARWOTDFEEDAUTHOR, '%author'), array('%author' => $node->name)) ;
    }
  }

/**
 * Define user permissions.
 *
 * This hook can supply permissions that the module defines, so that they
 * can be selected on the user permissions page and used to restrict
 * access to actions the module performs.
 *
 * @return array An array of permissions strings.
 *
 * Permissions are checked using user_access().
 */
function g2_perm() {
  return array
    (
    G2PERMADMIN,
    G2PERMVIEW
    );
}

/**
 * Declare administrative settings for a module.
 *
 * This hook provides an administrative interface for controlling various
 * settings for this module. A menu item for the module under "administration >>
 * settings" will appear in the administrative menu when this hook is implemented.
 *
 * @return array
 *   An array containing form items to place on the module settings
 *   page.
 *
 * The form items defined on the settings page will be saved with
 * variable_set(), and can be later retrieved with variable_get(). If you
 * need to store more complicated data (for example, in a separate table),
 * define your own administration page and link to it using hook_menu().
 */
function g2_settings() {
  $form['main'] = array(
    '#type'          => 'fieldset',
    '#title'         => t('Main page'),
    );
  $form['main'][G2VARMAIN] = array(
    '#type'          => 'textfield',
    '#title'         => t('Node used for the main page of G2 on this site'),
    '#default_value' => variable_get(G2VARMAIN, 0),
    '#description'   => t('<p>When themeing for G2 is supplied by a non-G2-aware theme, the <code>theme_g2_main</code> function will use this node as the main page for the G2 glossary, wrapped between alphabars. This node will typically be an unpublished page or story node. G2-aware themes can provide their own home page, using this page as a basis, or not.</p>'),
    );
  $form['main'][G2VARPATHMAIN] = array(
    '#type'          => 'textfield',
    '#title'         => t('Path for the main page of G2 on this site'),
    '#default_value' => variable_get(G2VARPATHMAIN, G2DEFAULTPATHMAIN),
    '#description'   => t('<p>This setting allows site admins to modify the URL at which the home page will be found.
         This will typically be done to replace the standard path ("g2") by a SEO-engineered path.</p>'),
    );
  $form['main'][G2VARPAGETITLE] = array(
    '#type'          => 'textfield',
    '#title'         => t('Override for site title on G2 pages'),
    '#default_value' => variable_get(G2VARPAGETITLE,G2DEFAULTPAGETITLE),
    '#description'   => t('<p>This setting allows site admins to modify the site title on G2 page, typically for SEO purposes. The title can include %title, which will be replaced by the standard Drupal site title. If set to empty, the default site name will not be overriden.</p>'),
    );

  $form['automation'] = array(
    '#type'          => 'fieldset',
    '#title'         => t('Site automation')
    );
  $form['automation'][G2VARHIDDENTITLE] = array
    (
    '#type'          => 'checkbox',
    '#title'         => t('Embed a CSS-masked version of the definition titles in the node rendition'),
    '#default_value' => variable_get(G2VARHIDDENTITLE, TRUE),
    '#description'   => t('This setting enables search to work better on definition titles, but can be frowned upon by search engines.'),
    );
  $form['automation'][G2VARNOFREETAGGING] = array
    (
    '#type'          => 'checkbox',
    '#title'         => t('Hide terms from free-tagging vocabularies to users without G2 administrator permissions.'),
    '#default_value' => variable_get(G2VARNOFREETAGGING, TRUE),
    '#description'   => t('Terms bound to a G2 node belonging in a free tagging vocabulary
         are typically not meant for end-user consumption.'),
    );
  $form['remoting'] = array
    (
    '#type'          => 'fieldset',
    '#title'         => t('Remoting'),
    );
  $def = variable_get(G2VARREMOTEG2, G2DEFAULTREMOTEG2);
  if (empty($def))
    {
    $def = G2DEFAULTREMOTEG2 ;
    }
  $form['remoting'][G2VARREMOTEG2] = array
    (
    '#type'          => 'textfield',
    '#title'         => t('Use the URL of this remote G2 glossary, or %local for a local glossary',
      array(
        '%local' => '<code>' . check_plain(G2DEFAULTREMOTENO) . '</code>',
        )
      ),
    '#default_value' => $def,
    '#description'   => t('Using G2 remoting, you can supply automatic links from your site to a glossary on another site, without having to maintain anything locally. You will just need to enable the "G2 Glossary Filter" at %url for each format using it. Use %local to maintain a glossary on your site. Erase the field and save TWICE to restore the default value, the Riff dictionary of computing.',
      array(
        '%url' => l('input formats', 'admin/filters'),
        '%local' => '<code>' . check_plain(G2DEFAULTREMOTENO) . '</code>',
        )
      ),
    );
  $form['homonyms'] = array(
    '#type'          => 'fieldset',
    '#title'         => t('Homonyms processing')
    );
  $form['homonyms'][G2VARHOMONYMS] = array(
    '#type'          => 'textfield',
    '#title'         => t('Node used for the homonyms disambiguation page of G2 on this site'),
    '#default_value' => variable_get(G2VARHOMONYMS, 0),
    '#description'   => t('If this node is non-zero, this is the page used to build the disambiguation
          page for G2 entries at <code>&lt;drupal&gt;/g2/entries/&lt;someentry&gt;</code>.
          Otherwise, a default page is used.'),
    );
  $form['homonyms'][G2VARGOTOSINGLE] = array
    (
    '#type'          => 'checkbox',
    '#title'         => t('Enable auto-jump to single match on entry'),
    '#default_value' => variable_get(G2VARGOTOSINGLE, TRUE),
    '#description'   => t('This setting enables automatic redirection from
          <code>&lt;drupal&gt;/g2/entries/someeentry</code> to the entry page if only one match exists for "someentry".
          This is especially useful for links generated from content nodes.'),
    );
  $form['homonyms'][G2VARHOMONYMSREDIRECT] = array
    (
    '#type'          => 'select',
    '#title'         => t('The type of HTTP redirection to be used if auto-jump is enabled'),
    '#default_value' => variable_get(G2VARHOMONYMSREDIRECT, G2DEFAULTHOMONYMSREDIRECT),
    '#options'       => array (
      '301'                     => t('Permanent redirect (HTTP 301)'),
      G2DEFAULTHOMONYMSREDIRECT => t('Temporary redirect (HTTP 302)'),
      ),
    '#description'   => t('If the "auto-jump to single match on entry" feature is enabled,
      choose which type of redirection is generated. Technically, a temporary redirect (302)
      makes more sense, especially is the glossary is often updated, but if the glossary
      is stable, or if the site admin has reason to fear a 302 search engine blacklisting,
      this setting makes it possible to use a permanent (301) redirect.
      Note that this requires the enhanced version of drupal_goto to be available.
      See <a href="http://drupal.org/node/75803">issue #75803</a> for details.'),
    );


  $arVoc = array ('0'  => t('None'));
  foreach (taxonomy_get_vocabularies(G2NODETYPE) as $voc)
    {
  	$arVoc[$voc->vid] = $voc->name;
    }
  $form['homonyms'][G2VARHOMONYMSVID] = array(
    '#type'          => 'select',
    '#title'         => t('Vocabulary to be used on the homonyms disambiguation page'),
    '#default_value' => variable_get(G2VARHOMONYMSVID, 0),
    '#description'   => t('If a vocabulary is chosen here, the terms bound to ambiguous entries (homonyms)
          will be displayed on the defaut disambiguation page.'),
    '#options'       => $arVoc,
    );

  $form['advanced'] = array(
    '#type'          => 'fieldset',
    '#title'         => t('Advanced settings (for programmers only)'),
    '#collapsible'   => true,
    '#collapsed'     => true,
    );
  $form['advanced'][G2VARXMLRPC] = array
    (
    '#type'          => 'checkbox',
    '#title'         => t('Enable G2 remote XML-RPC services'),
    '#default_value' => variable_get(G2VARXMLRPC, FALSE),
    '#description'   => t('This setting enables remote anonymous use of the G2 glossary through its XML-RPC services.
         Enabling it without additional access control is typically not a good idea.
         Note that local XML-RPC is always enabled, which may need to be modified on shared hosts.'),
    );

  $form['advanced'][G2VARRPCTHROTTLE] = array
    (
    '#type'          => 'textfield',
    '#title'         => t('RPC throttle'),
    '#default_value' => variable_get(G2VARRPCTHROTTLE, G2DEFAULTRPCTHROTTLE),
    '#description'   => t('This setting is a coefficient applied to the Top and Latest block for their XML-RPC services.
        It defines the maximum number of entries an XML-RPC client is allowed to return
        in just one call as the product of the block setting and this coefficient.'),
    );
  $form['advanced'][G2VERSION] = array
    (
    '#value'         => '<p>'
      . t('This site is running G2 version %version. See the <a href="%page" title="G2 Glossary project page">G2 project page</a> on Drupal.org.',
        array(
          '%version' => G2VERSION,
          '%page'    => 'http://drupal.org/node/41641',
          )
        )
      . '</p>',
    );

  $form[G2PATHREFERERWIPE] = array
    (
    '#type'          => 'submit',
    '#value'         => G2TITLEREFERERWIPE,
    '#weight'        => 2,
    '#callback'      => _g2_referer_wipe,
    );
  return $form;
  }

/**
 * hook_settings form validation: if "wipe referers" has been chosen, ask for confirmation
 *
 * @param string $form_id
 * @param array $form
 * @return void
 */
function g2_settings_form_validate($form_id, &$form)
  {
  if ($_POST['op'] == G2TITLEREFERERWIPE)
    {
    drupal_goto(G2PATHREFERERWIPE);
    }
  }

/**
 * Respond to node updating.
 *
 * This is a hook used by node modules. It is called to allow the module
 * to take action when an edited node is being updated in the database by,
 * for example, updating information in related tables.
 *
 * @param $node int
 *   The node being updated.
 * @return void
 *   None.
 *
 * To take action when nodes of any type are updated (not just nodes of
 * the type(s) defined by this module), use hook_nodeapi() instead.
 */
function g2_update($node) {
  db_query("UPDATE {g2_node} SET period = '%s', complement = '%s', origin = '%s' WHERE nid = %d",
    $node->period, $node->complement, $node->origin, $node->nid);
}

/**
 * Implement hook_user
 *
 * @param string $op
 * @param array $edit
 * @param object $user
 * @param string $category
 * @return mixed
 */
function g2_user($op, &$edit, &$user, $category = NULL)
  {
  switch ($op)
    {
  	case 'load':
  	  $sq = "SELECT n.nid, n.title FROM {node} n WHERE n.type = '"
  	    . G2NODETYPE
  	    . "' AND n.uid = %d ORDER BY n.changed DESC, n.created DESC";
  	  $q = db_query_range($sq, $user->uid, 0, 10);
  	  $user->nodes = array();
  	  while ($o = db_fetch_object($q))
  	    {
  	    $user->nodes[] = array('value' => l($o->title, "node/$o->nid", NULL, NULL, NULL, TRUE));
        }
      break;
  	case 'view':
  	  if (isset($user->nodes))
  	    {
  	    $title = array('title' => t('10 most recently changed only'));
  	    array_unshift($user->nodes, $title);
  	    return array(t('Owned G2 nodes') => $user->nodes);
  	    }
      break;
  	default:
     //dprint_r($op)  ;
  	  break;
    }
  }

/**
 * Verify a node editing form.
 *
 * This is a hook used by node modules. It is called to allow the module
 * to verify that the node is in a format valid to post to the site. It
 * can also be used to make changes to the node before submission, such
 * as node-type-specific formatting. Errors should be set with
 * form_set_error().
 *
 * @param &$node
 *   The node to be validated.
 *
 * To validate nodes of all types (not just nodes of the type(s) defined by
 * this module), use hook_nodeapi() instead.
 *
 * For a detailed usage example, see node_example.module.
 */
function g2_validate(&$node) {
  if ($node) {
    if ($node->end && $node->start) {
      if ($node->start > $node->end) {
        form_set_error('time', t('An event may not end before it starts.'));
      }
    }
  }
}

/**
 * Display a node.
 *
 * This is a hook used by node modules. It allows a module to define a
 * custom method of displaying its nodes, usually by displaying extra
 * information particular to that node type.
 *
 * @param $node object
 *   The node to be displayed.
 * @param $teaser boolean
 *   Whether we are to generate a "teaser" or summary of the node, rather than
 *   display the whole thing.
 * @param $page boolean
 *   Whether the node is being displayed as a standalone page. If this is
 *   TRUE, the node title should not be displayed, as it will be printed
 *   automatically by the theme system. Also, the module may choose to alter
 *   the default breadcrumb trail in this case.
 * @return  void
 *   None. The passed-by-reference $node parameter should be modified as
 *   necessary so it can be properly presented by theme('node', $node). This
 *   means, for instance, that content should be passed through the filter
 *   system by calling check_output() on appropriate fields or by sending the
 *   node through node_prepare().
 */
function g2_view(&$node, $teaser = FALSE, $page = FALSE)
  {
  global $conf;

/**
 * @todo FGM 20051215: This will have to be reexamined later
 */
/*
  if ($page)
    {
    $breadcrumb = array();
    $breadcrumb[] = array('path' => variable_get(G2VARPATHMAIN, G2DEFAULTPATHMAIN), 'title' => t('G2'));
    $breadcrumb[] = array('path' => variable_get(G2VARPATHMAIN, G2DEFAULTPATHMAIN) . "/$node->title",
      'title' => t('%category', array('%category' => $node->title)));
    $breadcrumb[] = array('path' => 'node/'. $node->nid);
    menu_set_location($breadcrumb);
    }
 */

  //echo "<pre>In g2_view, node = " . print_r($node,TRUE) . "</pre>";
  $node = node_prepare($node, $teaser);
  $node->body = theme('g2_body', t('Definition'), $node->body);
  if (isset ($node->teaser) && ($node->teaser <> ''))
    $node->body = theme('g2_teaser', t('In other words'), $node->teaser) . $node->body ;
  if (isset ($node->period) && ($node->period <> ''))
    $node->body .= theme('g2_period', t('Term time period'), $node->period);

  // Modify the default page title as built by Drupal.
  /**
   * Tweaking $conf modifies only the live copy used by Drupal, not the stored value
   * as would be the case using variable_set
   * */
  if (variable_get(G2VARPAGETITLE, G2DEFAULTPAGETITLE))
    {
    $conf['site_name'] = strtr(variable_get(G2VARPAGETITLE, G2DEFAULTPAGETITLE),
      array('%title' => $conf['site_name'])) ;
    }

  // The following line adds invisible text that will be available to the default node update_index
  // It is prepended to the node in case some later search routine favors the beginning of the body
  // It can be turned off in case search engines frown upon this.
  if (variable_get(G2VARHIDDENTITLE, TRUE))
    $node->body = '<div style="display: none">' . check_plain($node->title) . '</div>' . $node->body;

  // Modify displayed taxonomy according to our settings
  $taxonomy = taxonomy_node_get_terms($node->nid);
  $taxonomy = _g2_comb_taxonomy($taxonomy);
  $node->taxonomy = array();
  foreach ($taxonomy as $term)
    {
  	$node->taxonomy[] = $term;
    }

  global $base_url;
  $referer = referer_uri();
  if (strpos($referer, $base_url . '/') === 0) // MUST use ===, otherwise False would match too
    {
    $referer = substr($referer, strlen($base_url) + 1); // Is now a local path
    $referer = drupal_get_normal_path($referer); // Is now an unaliased local path
    $referer = check_plain($referer);
    $sq = "UPDATE {g2_referer} SET incoming = incoming + 1 WHERE nid = %d AND referer = '%s'" ;
    db_query($sq, $node->nid, $referer);
    if (!db_affected_rows())
      {
      $sq = "INSERT INTO {g2_referer} (nid, referer, incoming) VALUES (%d, '%s', 1)";
      db_query($sq, $node->nid, $referer);
      }
    }
  else
    {
    /**
     * Referer is non-local.
     * Maybe we'll do something later on, but not right now
     */
    }
  }


/**
 * Register XML-RPC callbacks.
 *
 * This hook lets a module register callback functions to be called when
 * particular XML-RPC methods are invoked by a client.
 * WARNING: the default security method always allows local RPC.
 * In many low-cost shared hosting situations, this may not be safe
 * (but sites using low-cost shared hosting are typically not expected
 * to be needing g2)
 *
 * @return array
 *   An array which maps XML-RPC methods to Drupal functions. Each array
 *   element is either a pair of method => function or an array with four
 *   entries:
 *   - The XML-RPC method name (for example, module.function).
 *   - The Drupal callback function (for example, module_function).
 *   - The method signature is an array of XML-RPC types. The first element
 *     of this array is the type of return value and then you should write a
 *     list of the types of the parameters. XML-RPC types are the following
 *     (See the types at http://www.xmlrpc.com/spec):
 *       - "boolean": 0 (false) or 1 (true).
 *       - "double": a floating point number (for example, -12.214).
 *       - "int": a integer number (for example,  -12).
 *       - "array": an array without keys (for example, array(1, 2, 3)).
 *       - "struct": an associative array or an object (for example,
 *          array('one' => 1, 'two' => 2)).
 *       - "date": when you return a date, then you may either return a
 *          timestamp (time(), mktime() etc.) or an ISO8601 timestamp. When
 *          date is specified as an input parameter, then you get an object,
 *          which is described in the function xmlrpc_date
 *       - "base64": a string containing binary data, automatically
 *          encoded/decoded automatically.
 *       - "string": anything else, typically a string.
 *   - A descriptive help string, enclosed in a t() function for translation purposes.
 *   Both forms are shown in the example.
 */
function g2_xmlrpc()
  {
  $ret = array(
    'g2.alphabar'          => '_g2_alphabar',
    'g2.latest'            => '_g2_latest',
    'g2.random'            => '_g2_random',
    'g2.stats'             => '_g2_stats',
    'g2.top'               => '_g2_top',
    'g2.wotd'              => '_g2_wotd',
  );

  if ((variable_get(G2VARXMLRPC, FALSE) == false)
    && ($_SERVER['REMOTE_ADDR'] != $_SERVER['SERVER_ADDR'])) // We always allow local RPC
    {
    foreach ($ret as $methodname => $methodfun)
      {
      $ret[$methodname] = _g2_ip_ban;
      }
    }
  return $ret;
  }

/**
 * Ancillary function for g2_block to return a themed alphabar g2_block(view, 0)
 *
 * @return string HTML
 */
function theme_g2_block_alphabar()
  {
  $rowlen = variable_get(G2VARALPHABARROWLEN, 13);
  $links = _g2_alphabar();
  $ret = '';
  $i = 0;
  foreach ($links as $link)
    {
    $ret .= $link;
    if ($i % $rowlen == $rowlen - 1)
      $ret .= '<br/>';
    $i++;
    }
  return $ret;
  }

/**
 * Ancillary function for g2_block to generate a themed "latest n" block
 * @return string HTML
 */
function theme_g2_block_latest()
  {
  $arLatest = _g2_latest();
  $ar = array();
  foreach ($arLatest as $latest)
    {
    if ($latest->status == 1)
      $ar[] = l($latest->title, "node/$latest->nid");
    else
      $ar[] = $latest->title . t(' [offline]');
    }
  $ret = theme('item_list', $ar);
  return $ret;
  }

/**
 * Ancillary function for g2_block to generate a themed "random entry" block body
 * @return string HTML
 */
function theme_g2_block_random()
  {
  $o = _g2_random();

  $ret = l($o->title, "node/$o->nid");
  if ($o->teaser)
    $ret .= t(': %teaser', array('%teaser' => $o->teaser)); // Why t() ? Because varying languages have varying takes on spaces before/after semicolons
  $ret .= l(t(' (+)'), "node/$o->nid", array('class' => 'read-more'));
  $ret .= _g2_entry_terms($o); // No need to test: it won't change anything if a taxonomy has not been returned
  }

/**
 * Ancillary function for g2_block to generate a themed "top n" block
 * @return string HTML
 */
function theme_g2_block_top()
  {
  $tops = _g2_top();
  $ar = array();
  foreach ($tops as $top)
    {
    if ($top->status == 1)
      $ar[] = l($top->title, "node/$top->nid");
    else
      $ar[] = $top->title . t(' [offline]');
    }
  $ret = theme('item_list', $ar);
  return $ret;
  }

/**
 * @return object title / nid / teaser / [body]
 */
function theme_g2_block_wotd()
  {
  $bodysize = variable_get(G2VARWOTDBODYSIZE, 0);
  $o = _g2_wotd($bodysize);

  $ret = l($o->title, "node/$o->nid");
  if (isset($o->teaser) and ($o->teaser <> ''))
    {
    $teaser = '<span id="g2_wotd_teaser">' . $o->teaser . '</span>';
    $ret .= t(': %teaser', array('%teaser' => $teaser));
    unset($teaser);
    }
  if (isset($o->body) and ($o->body <> '')) // Won't be set if bodysize is 0
    {
    $strippedbody = strip_tags($o->body);
    $trimmedbody = substr($strippedbody, 0, $bodysize);
    if (strlen($trimmedbody) < strlen($strippedbody))
      $trimmedbody .= '&hellip;';
    $ret .= '<div id="g2_wotd_body">' . $trimmedbody . '</div>';
    }
  $ret .= l(t(' (+)'), "node/$o->nid", array('class' => 'read-more'));
  $ret .= _g2_entry_terms($o); // No need to test: it won't change anything if a taxonomy has not been returned
  if (variable_get(G2VARWOTDFEED, TRUE))
    $ret .= theme('xml_icon', url(G2PATHWOTDFEED, NULL, NULL, TRUE));
  return $ret;
  }

/**
 * Return a simple nodepage built with alphabars wrapping a node
 * to serve as the main page for the G2 glossary. If no node
 * is set, just return an alphabar.
 * @see _g2_main()
 *
 * @return string HTML
 */
function theme_g2_main()
  {
  $alphabar = theme('links', _g2_alphabar(), ' ');

  $node = node_load(variable_get(G2VARMAIN, 0));
  if (is_object($node))
    {
    drupal_set_title($node->title);
    $node->body = isset($node->body) ? ($alphabar .  $node->body . $alphabar) : $alphabar;
    $ret .= node_view($node, false, true); // theme('box', $node->body, FALSE, TRUE) ;
    }
  else
    {
    $ret = $alphabar;
    }
  return $ret;
  }

/**
 * Return a homonyms disambiguation page, built:
 * - either by this module
 * - either from a site node (typically in PHP input format)
 * When examining the code to build $entry, remember that
 * we need to obtain slashes, which drupal preprocesses
 * Note that we query and use n.title instead of using $entry2
 * in the results to obtain mixed case results when they exist
 * @return string
 */
function theme_g2_entries()
  {
  $nid = variable_get(G2VARHOMONYMS, 0); // The nid for the disambiguation page
  if ($nid > 0)
    {
    $node = node_load($nid);
    $ret .= node_view($node);
    }
  else
    {
    $count = 0 ;
    $nid = 0 ;
    $entry = filter_xss($_REQUEST['q']);
    $entry = html_entity_decode($entry, ENT_NOQUOTES, 'UTF-8');
    $entry = substr($entry, strlen(G2PATHENTRIES) + 1);
    if (($vid = variable_get(G2VARHOMONYMSVID, 0)) != 0)
      {
      // We query n.title instead of using $entry in the results to obtain mixed case results
      $sq = "SELECT distinct n.nid, n.title, v.teaser, td.name "
          . "FROM {node} n "
          . "INNER JOIN {node_revisions} v on n.vid = v.vid "
          . "LEFT  JOIN {term_node} tn on n.nid = tn.nid " // Some nodes may not be categorized
          . "INNER JOIN {term_data} td on tn.tid = td.tid "
          . "WHERE n.type='" . G2NODETYPE . "' AND (n.status = 1) AND (n.title = '%s') AND (td.vid = %d)"
          . "ORDER BY 1, 3 "; // Order by 1 is needed for multi-termed nodes
          ;
      $q = db_query($sq, $entry, $vid);
      $ar = array();
      $current_nid = 0;
      $row = '';
      while ($result = db_fetch_object($q))
        {
        if ($result->nid != $current_nid) // This is a new entry
          {
          $ar[] = "</span>$row";
          $current_nid = $result->nid;
          $row = l($result->title, "node/$result->nid")
            . t(': %teaser', array('%teaser' => check_plain($result->teaser)))
            . l(' (+)', "node/$result->nid", array('class' => 'read-more'))
            . '<span class="taxonomy">';
          $count++;
          }
        if (isset($result->name))
          $row .= ' ' . $result->name;
        }
      $ar[] = $row;
      array_shift($ar);
      }
    else
      {
      $sq = "SELECT n.nid, n.title, v.teaser "
          . "from {node} n inner join {node_revisions} v on n.vid = v.vid "
          . "where n.type='" . G2NODETYPE . "' and (n.status = 1) and (n.title = '%s')";
      $q = db_query($sq, $entry);
      $ar = array();
      while ($result = db_fetch_object($q))
        {
        $ar[] = l($result->title, "node/$result->nid")
          . t(': %teaser', array('%teaser' => check_plain($result->teaser)))
          . l(' (+)', "node/$result->nid", array('class' => 'read-more'));
        $current_nid = $result->nid;
        $count++;
        }
      }
    if ($count == 1) // Single answer, we can jump to it automatically
      if (variable_get(G2VARGOTOSINGLE, TRUE)) // Does the webmaster want us to jump ?
        {
        /**
         * Code for default version of drupal_goto
         */
        drupal_goto("node/$current_nid") ;
        /**
         * On sites implementing the enhanced drupal_goto version, this can
         * replace the standard code above/
        $redirect_type = variable_get(G2VARHOMONYMSREDIRECT, G2DEFAULTHOMONYMSREDIRECT);
        drupal_goto("$node/$current_nid", $redirect_type);
         */

        // Never returns
        }
      else
        {
        }
    if ($count == 0)
      {
      $ret = t('<p>There are currently no entries for "%entry".</p>', array('%entry' => $entry));
      if (user_access(G2PERMADMIN))
        {
        $ret .= t('<p>Would you like to <a href="%url" title="Create new entry for %entry">create</a> one ?</p>',
          array('%url' => url(G2PATHNODEADD . '/' . $entry), '%entry' => $entry));
        }
      }
    else // Must include the == 1 case
      {
      $ret .= theme('item_list', $ar);
      }
    }
  return $ret;
  }

/**
 * Return a themed page listing entries by initial segment
 * @param string $initial Set automagically when invoked from hook_menu
 * @return string HTML
 */
function theme_g2_initial($initial = NULL)
  {
  drupal_set_title(strtr(G2TITLEINITIAL, array('%initial' => $initial)));
  $ret .= _g2_initial($initial);
  return $ret;
  }

/**
 * Return a themed g2 node body
 *
 * @param title $title The title for the body container
 * @param body $body The body itself
 * @return string HTML
 */
function theme_g2_body($title, $body)
  {
  return theme('box', $title, $body);
  }

/**
 * Return a themed g2 node teaser
 * Teasers normally contain expansions for acronyms/initialisms,
 * or translations for foreign terms
 *
 * @param title $title The title for the teaser container
 * @param body $body The teaser itself
 * @return string HTML
 */
function theme_g2_teaser($title, $teaser)
  {
  return theme('box', $title, "<p>$teaser</p>");
  }

/**
 * Return a themed g2 node time period
 *
 * @param title $title The title for the period container
 * @param body $body The period itself
 * @return string HTML
 */
function theme_g2_period($title, $period)
  {
  return theme('box', $title, "<p>$period</p>");
  }

/**
 * Encodes terminal path portions for G2. This allows linking to
 * things containing #, + or '.', like C++, C# or the . initial
 *
 * Warning: this is NOT a generic replacement for urlencode, but
 * covers a very specific glossary-related need.
 *
 * @param unknown_type $terminal
 */
function _g2_terminal_encode($terminal)
  {
  $terminal = strtr($terminal, array(
    '.' => '%2E',
    '/' => '%2F',
    '#' => '%23',
    '&' => '%26',
    '+' => '%2B',
    )) ;
  return $terminal;
  }